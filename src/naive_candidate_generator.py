# Adapted from CS124 Winter Quarter 2018, Assignment 2
# Naive, O(m^n+n) implementation of generator for all possible words of Levenshtein edit distance 1
# First four functions return all possible strings generated by performing one type of edit.
# (e.g. deleteEdits('abc') returns ['bc', 'ac', 'ab'])
# get_edits calls all four functions and returns the complete list of edit distance 1 words

ALPHABET = 'abcdefghijklmnopqrstuvwxyz'

def deleteEdits(word):
    """Returns a list of edits of 1-delete distance words and rules used to generate them."""
    if len(word) <= 0:
      return []

    word = "<" + word #Append start character
    ret = []
    for i in range(1, len(word)):
      #The corrupted signal are this character and the character preceding
      corruptLetters = word[i-1:i+1] 
      #The correct signal is just the preceding character
      correctLetters = corruptLetters[:-1]

      #The corrected word deletes character i (and lacks the start symbol)
      correction = "%s%s" % (word[1:i], word[i+1:])
      ret.append(correction)
      
    return ret

def insertEdits(word):
    """Returns a list of edits of 1-insert distance words and rules used to generate them."""
    word = "<" + word # append start token
    ret = []
    # For every position in the word, try inserting every character in the alphabet
    for i in range(0, len(word)):
        for char in ALPHABET:
          #The corrected word inserts char after character i (and lacks the start symbol)
          correction = "%s%s%s" % (word[1:i+1], char, word[i+1:])
          ret.append(correction)
    return ret

def transposeEdits(word):
    """Returns a list of edits of 1-replace distance words and rules used to generate them."""
    ret = []
    # Loop through every position and try switching characters with the next position
    for i in range(0, len(word)-1):
      #The corrupted signal are this character and the next character
      corruptLetters = word[i:i+2]
      #The correct signal consists of those two characters swapped
      # (only two characters, so the same thing as the reversed list)
      correctLetters = corruptLetters[::-1]

      #The corrected word swaps characters i and i+1
      correction = "%s%s%s" % (word[0:i], correctLetters, word[i+2:])
      ret.append(correction)
    return ret

def replaceEdits(word):
    """Returns a list of edits of 1-replace distance words and rules used to generate them."""
    ret = []
    # Try replacing every position in word with every char in alphabet
    for i in range(0, len(word)):
      for char in ALPHABET:
        if(char != word[i]):
            #The corrected word replaces character i with char
            correction = "%s%s%s" % (word[0:i], char, word[i+1:])
            ret.append(correction)
    return ret

def get_edits(word):
    """Returns a list of tuples of 1-edit distance words and rules used to generate them, e.g. ("test", "te|et")"""
    return  deleteEdits(word) + \
      insertEdits(word) + \
      transposeEdits(word) + \
      replaceEdits(word)
